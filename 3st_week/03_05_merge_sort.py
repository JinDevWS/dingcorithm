# 그런데, 의문이 생길 수 있습니다. 
# 이 방법으로 어떻게 정렬을 할 수 있는건가요?
# 이건 그냥 정렬된 배열을 합치는 거 아닌가요?
# 바로, 분할 정복의 개념을 적용하면 됩니다.

# 분할 정복은 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략입니다. (divide & conquer)

# 예를 들어서 [5, 4] 라는 배열이 있다면  
# 이 배열을 [5] 와 [4] 를 가진 각각의 배열로 작은 2개의 문제로 분리해서 생각하는 것입니다.
# 그러면 이 둘을 합치면서 정렬한다면? 결국 전체의 정렬된 리스트가 될 수 있습니다.

# 이 개념을 조금 더 확대해서 생각해보겠습니다.

# [5, 3, 2, 1, 6, 8, 7,  4] 이라는 배열이 있다고 하겠습니다. 이 배열을 반으로 쪼개면
# [5, 3, 2, 1] [6, 8, 7, 4] 이 됩니다. 또 반으로 쪼개면
# [5, 3] [2, 1] [6, 8]  [7, 4] 이 됩니다. 또 반으로 쪼개면
# [5] [3] [2] [1] [6] [8] [7] [4] 이 됩니다.

# 이 배열들을 두개씩 병합을 하면 어떻게 될까요?
# [5] [3] 을 병합하면 [3, 5] 로
# [2] [1] 을 병합하면 [1, 2] 로
# [6] [8] 을 병합하면 [6, 8] 로
# [7] [4] 을 병합하면 [4, 7] 로
# 그러면 다시! 
# [3, 5] 과 [1, 2]을 병합하면 [1, 2, 3, 5] 로
# [6, 8] 와 [4, 7]을 병합하면 [4, 6, 7, 8] 로
# 그러면 다시!
# [1, 2, 3, 5] 과 [4, 6, 7, 8] 를 병합하면 [1, 2, 3, 4, 5, 6, 7, 8] 이 됩니다.

# 어떤가요? 문제를 쪼개서 일부분들을 해결하다보니, 어느새 전체가 해결되었습니다!
# 이를 분할 정복, Divide and Conquer 라고 합니다. 
# 이렇게 동일한 형태로 반복되는 경우에는 어떤 코드가 생각나나요?
# 바로 "재귀" 적인 코드가 떠오릅니다.

# 자기 자신을 포함하는 형식으로 함수를 이용해서 정의해보면,
# MergeSort(시작점, 끝점) 이라고 해볼게요.

# 그러면 
# MergeSort(0, N) = Merge(MergeSort(0, N/2) + MergeSort(N/2, N))
#  라고 할 수 있습니다.

# 즉, 0부터 N까지 정렬한 걸 보기 위해서는 
# 0부터 N/2 까지 정렬한 것과 N/2부터 N까지 정렬한 걸 합치면 된다. 라는 개념입니다.

# 아까 봤던 [1, 2, 3, 5] 와 [4, 6, 7, 8] 을 합치면 정렬된 배열이 나온 것 처럼요!

# 자, 이제 그러면 위의 생각들을 코드로 옮겨보겠습니다! 
# def merge_sort(array):
# mid = (0 + len(array)) // 2
# left_array = merge_sort(array[:mid])  # 왼쪽 부분을 정렬하고
# right_array = merge_sort(array[mid:]) # 오른쪽 부분을 정렬한 다음에
# merge(left_array, right_array)        # 합치면서 정렬하면 됩니다!

# 재귀 함수의 형태로 만들어졌습니다!
# 엇 그런데 재귀 함수의 필수 조건, **탈출 조건**을 안 써줬네요!

# 어느 시점에 탈출하죠?
# 문자열의 길이가 1보다 작거나 같을 때, 
# 무조건 정렬되었다고 볼 수 있을테니 (하나밖에 없으니까요!)
# 탈출시키도록 하면 됩니다!
# def merge_sort(array):
#     if len(array) <= 1:
#         return array
#     mid = (0 + len(array)) // 2
#     left_array = merge_sort(array[:mid])   # 왼쪽 부분을 정렬하고
#     right_array = merge_sort(array[mid:])  # 오른쪽 부분을 정렬한 다음에
#     merge(left_array, right_array)         # 합치면서 정렬하면 됩니다!
# 이 개념을 가시고 한 번 병합정렬을 구현하러 가보겠습니다!


array = [5, 3, 2, 1, 6, 8, 7, 4]

def merge_sort(array):
    if len(array) <= 1:
        return array
    mid = (0 + len(array)) // 2
    left_array = merge_sort(array[:mid])   # 왼쪽 부분을 정렬하고
    right_array = merge_sort(array[mid:])  # 오른쪽 부분을 정렬한 다음에
    array = merge(left_array, right_array)         # 합치면서 정렬하면 됩니다!
    
    return array


def merge(array1, array2):
    result = []
    array1_index = 0
    array2_index = 0
    while array1_index < len(array1) and array2_index < len(array2):
        if array1[array1_index] < array2[array2_index]:
            result.append(array1[array1_index])
            array1_index += 1
        else:
            result.append(array2[array2_index])
            array2_index += 1

    if array1_index == len(array1):
        while array2_index < len(array2):
            result.append(array2[array2_index])
            array2_index += 1

    if array2_index == len(array2):
        while array1_index < len(array1):
            result.append(array1[array1_index])
            array1_index += 1

    return result


print(merge_sort(array))  # [1, 2, 3, 4, 5, 6, 7, 8] 가 되어야 합니다!

print("정답 = [-7, -1, 5, 6, 9, 10, 11, 40] / 현재 풀이 값 = ", merge_sort([-7, -1, 9, 40, 5, 6, 10, 11]))
print("정답 = [-1, 2, 3, 5, 10, 40, 78, 100] / 현재 풀이 값 = ", merge_sort([-1, 2, 3, 5, 40, 10, 78, 100]))
print("정답 = [-1, -1, 0, 1, 6, 9, 10] / 현재 풀이 값 = ", merge_sort([-1, -1, 0, 1, 6, 9, 10]))



# 시간 복잡도

# merge() 함수
# while 문이 len(array1) 과 len(array2)의 길이 만큼 반복하고 있습니다.
# 즉, 최대 len(array1) + len(array2) 만큼의 연산량이 필요한데,
# 이의 최댓값은 O(N) 입니다!
# 왜냐면 array1과 array2 는 결국 array 를 반으로 잘라서 넣은 길이이기 때문입니다! 

# 그러면 merge 함수의 시간 복잡도는 O(N) 입니다.
# merge_sort 함수는 어떨까요?

# merge_sort 는 대입 연산과 비교 연산 몇 번밖에 나오지 않으므로
# 상수의 시간 복잡도를 가집니다!

# 그러므로 병합 정렬의 총 시간복잡도는 O(N)이라고 말하면 될까요?
# **그렇지 않습니다!**

# [5] [3] 을 병합하면 [3, 5] 로
# [2] [1] 을 병합하면 [1, 2] 로
# [6] [8] 을 병합하면 [6, 8] 로
# [7] [4] 을 병합하면 [4, 7] 로
# 그러면 다시! 
# [3, 5] 과 [1, 2]을 병합하면 [1, 2, 3, 5] 로
# [6, 8] 와 [4, 7]을 병합하면 [4, 6, 7, 8] 로
# 그러면 다시!
# [1, 2, 3, 5] 과 [4, 6, 7, 8] 를 병합하면 [1, 2, 3, 4, 5, 6, 7, 8] 이 됩니다.

# 위의 케이스에서 봤듯이, 저희는 
# [1, 2, 3, 4, 5, 6, 7, 8] 을 정렬하기 위해        
# [1, 2, 3, 5] 과 [4, 6, 7, 8] 을 병합했습니다. 

# [1, 2, 3, 5] 과 [4, 6, 7, 8] 을 정렬하기 위해 
# [3, 5] [1, 2] 과 [6, 8] [4,7] 을 병합했습니다. 

# [3, 5] [1, 2] 과 [6, 8] [4,7] 을 정렬하기 위해
# [5] [3] [2] [1] [6] [8] [7] [4] 를 병합했습니다.

# 여기서 병합하는 시간만 구해볼게요!

# 1단계 
# [1, 2, 3, 4, 5, 6, 7, 8] 을 정렬하기 위해    
# [1, 2, 3, 5] 과 [4, 6, 7, 8] 을 병합했습니다.

# 즉, 크기 N 인 배열을 병합하기 위해
# 크기 N/2 인 부분 배열 2개를 비교 합니다.
# 그러면 N/2 * 2 = N 의 길이만큼 연산하게 됩니다.

# 2단계
# [1, 2, 3, 5] 과 [4, 6, 7, 8] 을 정렬하기 위해 
# [3, 5] [1, 2] 과 [6, 8] [4,7] 을 병합했습니다.

# 즉, 크기 N/2 인 부분 배열 2개를 병합하기 위해
# 크기 N/4 인 부분 배열 4개를 비교 합니다.
# 그러면 N/4 * 4 = N 번 연산하게 됩니다.

# 3단계
# [3, 5] [1, 2] 과 [6, 8] [4,7] 을 정렬하기 위해   
# [5] [3] [2] [1] [6] [8] [7] [4] 를 병합했습니다.

# 즉, 크기 N/4 인 부분 배열 4개를 병합하기 위해
# 크기 N/8 인 부분 배열 8개를 비교 합니다.
# 그러면 N/8 * 8 = N 번 연산하게 됩니다.

# 즉 모든 단계에서 N 만큼 비교를 합니다.
# 그러면 총 몇 단계인지만 알면 시간 복잡도를 구할 수 있습니다!

# 크기가 N → N/2 → N/2^2 → N/2^3 → .... → 1

# k 번 만큼 2로 나눠서 1이 되는 순간.

# 즉, N/2^k = 1

# 이 되는 순간이 있을텐테, 어! 이거 저희 배웠었죠?  k = log_2N ! 이었죠?

# 바로 log_2N  번 반복하게 되면 1이 됩니다.


# merge 함수를 호출할건데, 몇번 호출하죠? 바로 log2N 만큼 호출하게 됩니다.
# 이 과정에서, merge 함수의 시간복잡도는 O(N)
# 따라서, merge 함수 호출하는 횟수 * merge 함수 시간 복잡도 = O(logN* N)


# 이걸 수식으로 나타내면 
# N만큼의 연산을 logN 번 반복한다고 해서 

# 시간 복잡도는 총 O(Nlog_2N) = O(NlogN) 이 된다! 라고 생각할 수 있습니다.
# (상수 2는 그냥 없애버림)

# 이 수식이 헷갈리신다면 다시 한 번 강의를 들어보세요!