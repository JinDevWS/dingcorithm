# 내부 반복문 안에서, 만약 
# array[i - j - 1] > array[i - j] 라면 두 값을 변경해주고,
# 아니라면 나가면 됩니다!

# 나가는 이유는? 이미 앞에 있는 원소들이 정렬이 되었으므로 
# 더 비교할 이유가 없기 때문입니다.

# 위의 예시 중 3단계에 해당합니다.

# 3단계 : [2, 4, 6, 9, 1]

# 신병인 9는 앞의 부대원인 6과 비교하지만 6 < 9 이기 때문에 그대로 냅둬도 됩니다.
# 이후에 9와 4를 비교할 필요가 있을까요? 없습니다! 
# 앞에 원소들은 이미 6보다 낮은 숫자들로 정렬되어 있을테니까요!

input = [4, 6, 2, 9, 1]


def insertion_sort(array):
    # 이 부분을 채워보세요!

    n = len(array)
    for i in range(1, n):
        for j in range(i):
            print("i", i)
            print("j", j)
            print("i - j - 1:", i - j - 1)
            print("i - j:", i - j)
            print("-----------")
            if array[i - j - 1] > array[i - j]:
                print("체인지")
                array[i - j - 1], array[i - j] = array[i - j], array[i - j - 1]
            else:
                print("!!!!!break!!!!!")
                break
        print("========================")
        print(array)
        print("========================")

    return array

insertion_sort(input)
print(input) # [1, 2, 4, 6, 9] 가 되어야 합니다!

print("정답 = [4, 5, 7, 7, 8] / 현재 풀이 값 = ",insertion_sort([5,8,4,7,7]))
print("정답 = [-1, 3, 9, 17] / 현재 풀이 값 = ",insertion_sort([3,-1,17,9]))
print("정답 = [-3, 32, 44, 56, 100] / 현재 풀이 값 = ",insertion_sort([100,56,-3,32,44]))



# 이것도 바로 $O(N^2)$ 만큼 걸립니다. 

# 그러나, 버블 정렬과 선택 정렬과 다른 면이 있습니다.
# 버블 정렬과 선택 정렬은 최선이든 최악이든 항~~상 $O(N^2)$ 만큼의 시간이 걸렸지만,

# 최선의 경우에는 $Ω(N)$ 만큼의 시간 복잡도가 걸립니다.
# 거의 정렬이 된 배열이 들어간다면 break 문에 의해서 
# 더 많은 원소와 비교하지 않고 탈출할 수 있기 때문입니다!