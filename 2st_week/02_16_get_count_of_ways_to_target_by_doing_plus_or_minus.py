# Q. 음이 아닌 정수들로 이루어진 배열이 있다. 
# 이 수를 적절히 더하거나 빼서 특정한 숫자를 만들려고 한다. 
# 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들기 위해서는 다음 다섯 방법을 쓸 수 있다.

# -1+1+1+1+1 = 3
# +1-1+1+1+1 = 3
# +1+1-1+1+1 = 3
# +1+1+1-1+1 = 3
# +1+1+1+1-1 = 3

# 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target_number이 매개변수로 주어질 때 
# 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 반환하시오.


# 이 문제의 예제에 들어있는 수가 1, 1, 1, 1, 1 이라서 
# 막 예시를 쓰시다가는 굉장히 헷갈리실 수가 있습니다.
# 따라서, 이런 경우에는 좀 더 쉬운 예제를 만들어서 풀어보시는 것이 좋습니다!
# 저 같은 경우는 numbers 가 [2, 3, 1]
# target_number 를 0이라고 해서 한 번 풀어보도록 하겠습니다!
# 자, 그러면 이제 2, 3, 1이라서 
# 어떻게 저렇게 잘하면 더하거나 빼서 몇번으로 만들 수 있을지 아는 규칙이 있지 않을까? 
# 라고 생각하기 쉽습니다. 
# 그러나, 이 문제는 모든 경우의 수를 다 해봐야지만 풀 수 있는 문제입니다!
# 일관적인 규칙을 찾을 수 없습니다!
# 그런데, 어떤 방식으로 모든 경우의 수를 파악할 수 있을까요? 
# 방법을 모르겠으면 우선 모든 경우의 수를 직접 써봅시다! 

# 1. +2 +3 +1 = 6
# 2. +2 +3 -1 = 4 
# 3. +2 -3 +1 = 0 # 타겟!
# 4. +2 -3 -1 = -2
# 5. -2 +3 +1 = 2 
# 6. -2 +3 -1 = 0 # 타겟!
# 7. -2 -3 +1 = -4
# 8. -2 -3 -1 = -6


# 첫번째 방법은 
# + + +
# 두 번째 방법은 
# + + -
# 세 번째 방법은 
# + - +
# 네 번째 방법은
# + - -
# .....
# 인데, 뭔가 반복되지 않나요?
# 이 구조를 축소시킬 수 있겠다는 감이 혹시 오시나요?
# 바로, 새로운 원소를 뺄지 더할지에 따라 방법이 추가된다는 걸 느낄 수 있습니다.
# 이를 함수로 작성해보면, 
# N의 길이의 배열에서 더하거나 뺀 모든 경우의 수는
# N-1 의 길이의 배열에서 마지막 원소를 더하거나 뺀 경우의 수를 추가하면 됩니다!
# 무슨 말이냐면,
# [2, 3] 을 배치하는 모든 경우의 수에서 
# 맨 마지막 원소인 1을 더하냐 빼냐에 따라서 [2, 3, 1] 의 경우의 수를 구할 수 있습니다. 

# [2, 3] 을 배치하는 모든 경우의 수는 아래와 같습니다.

# 1. +2 +3 
# 2. +2 -3
# 3. -2 +3
# 4. -2 -3 

# 여기서 1을 빼느냐 더하느냐에 따라 경우의 수가 다음과 같이 더 생깁니다.
              
# 1. +2 +3   → +1 = +2 +3 +1
#            → -1 = +2 +3 -1
# 2. +2 -3   → +1 = +2 -3 +1
#            → -1 = +2 -3 -1
# 3. -2 +3   → +1 = -2 +3 +1    
#            → -1 = -2 +3 -1
# 4. -2 -3   → +1 = -2 -3 +1
#            → -1 = -2 -3 -1

# 즉, 하나씩 원소를 추가할 때마다 
# 새로 추가된 원소를 더하고 빼는 경우의 수를 추가하면 됩니다.

# 즉, 이를 코드로 표현하면 다음과 같습니다!

# ===================================================================================================
import time

numbers = [2, 3, 1]
target_number = 0
result = []  # 모든 경우의 수를 담기 위한 배열

def get_count_of_ways_to_target_by_doing_plus_or_minus(array, target):
    # 구현해보세요!
    
    # 맨 처음 재귀함수를 호출하기
    # current_index 와 current_sum 에 0, 0을 넣은 이유는 시작하는 총액이 0, 시작 인덱스도 0이니까 그렇습니다!
    get_all_ways_by_doing_plus_or_minus(array, 0, 0, "스타트")

def get_all_ways_by_doing_plus_or_minus(array, current_index, current_sum, is_plus_or_minus):
    print(is_plus_or_minus, "들어옴")
    print("current_index", current_index)
    print("current_sum", current_sum)
    
    if current_index == len(array):  # 탈출조건!
        result.append(current_sum)  # 마지막 인덱스에 다다랐을 때 합계를 추가해주면 됩니다.
        print("-------- 탈출 ----------")
        return
    
    
    print("=========================")
    # 배열의 다음 인덱스를 받고,
    # 그리고 나서 추가된 인덱스 번째 원소를 더하거나 뺴거나 하는 형태로 두 가지의 경우가 나뉨
    get_all_ways_by_doing_plus_or_minus(array, current_index + 1, current_sum + array[current_index], "플러스")
    print("플러스 끝")

    get_all_ways_by_doing_plus_or_minus(array, current_index + 1, current_sum - array[current_index], "마이너스")
    print("마이너스 끝")


get_count_of_ways_to_target_by_doing_plus_or_minus(numbers, target_number)
print(result)
# 모든 경우의 수가 출력됩니다!
# [6, 4, 0, -2, 2, 0, -4, -6]
# ===================================================================================================